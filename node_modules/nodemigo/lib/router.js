"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Router;

var _lodash = _interopRequireDefault(require("lodash"));

var _onFinished = _interopRequireDefault(require("on-finished"));

var _prettyError = _interopRequireDefault(require("pretty-error"));

var _uuid = _interopRequireDefault(require("uuid"));

var _ipaddr = _interopRequireDefault(require("ipaddr.js"));

var _responseTime = _interopRequireDefault(require("response-time"));

var _debug = _interopRequireDefault(require("debug"));

var debug = (0, _debug.default)('router'); // Pretty Error

var pe = new _prettyError.default();
pe.skipNodeFiles(); // this will skip events.js and http.js and similar core node files

pe.skipPackage('express', 'bluebird', 'lodash');
/**
 * Extends `Express.Router` with additional features
 * Controllers can define routes that will be connected here
 *
 * Added Properties:
 *
 * - `routes` an array of connected routes
 *   (all, get, post, put, patch, delete)
 *
 * @return {Router} An instance of `Express.Router`
 */

function Router(_ref) {
  var express = _ref.express,
      _ref$options = _ref.options,
      options = _ref$options === void 0 ? {} : _ref$options,
      _ref$controllers = _ref.controllers,
      controllers = _ref$controllers === void 0 ? {} : _ref$controllers;

  if (!express || !_lodash.default.isFunction(express.Router)) {
    return null;
  } // Create a new `Express.Router` with `options`
  // eslint-disable-next-line new-cap


  var router = express.Router(options); // Alias all PATCH to PUT

  router.patch('*', function (req, res, next) {
    // eslint: no-param-reassign
    req.method = 'PUT';
    next();
  }); // Attach `db` to all requests

  if (options.db) {
    router.use(function (req, res, next) {
      req.db = options.db;
      next();
    });
  } // Set `X-Response-Time` header


  if (options.responseTime) {
    router.use((0, _responseTime.default)(options.responseTime));
  } // Assign a UUID to each request


  if (options.id) {
    router.use(function (req, res, next) {
      req.id = _uuid.default.v4();
      next();
    });
  }

  if (options.shouldLogIP) {
    // IP Address (converts ::ffff:127.0.0.1 to 127.0.0.1)
    router.use(function (req, res, next) {
      var ipString = req.ip;

      if (_ipaddr.default.IPv4.isValid(ipString)) {
        // ipString is IPv4
        req.ipv4 = req.ip;
      } else if (_ipaddr.default.IPv6.isValid(ipString)) {
        var ip = _ipaddr.default.IPv6.parse(ipString);

        if (ip.isIPv4MappedAddress()) {
          // IP Address (converts ::ffff:127.0.0.1 to 127.0.0.1)
          req.ipv4 = ip.toIPv4Address().toString();
        } else {
          // ipString is IPv6
          req.ipv6 = req.ip;
        }
      } else {
        // NO-OP: ipString is invalid
        req.ipv4 = null;
        req.ipv6 = null;
      }

      next();
    });
  }

  if (options.shouldLogRequest) {
    router.use(function (req, _res, next) {
      (0, _onFinished.default)(_res, function (err, res) {
        if (res.silent) {
          return;
        }

        var params = {
          method: req.method.toUpperCase(),
          url: req.url,
          status: res.statusCode,
          time: res.get('x-response-time') || 0
        };
        debug("".concat(params.method, " ").concat(params.url, " ").concat(params.status, " ").concat(params.time));
      });
      next();
    });
  }

  if (options.prettyError) {
    router.use(function (req, _res, next) {
      (0, _onFinished.default)(_res, function (err, res) {
        if (res.silent) {
          return;
        }

        if (res.err) {
          console.error(pe.render(res.err));
        }
      });
      next();
    });
  } // Additional properties


  _lodash.default.assign(router, {
    controllers: controllers,
    routes: [],

    /**
     * Iterates over all controllers and connects any routes defined
     */
    addControllerRoutes: function addControllerRoutes() {
      // Used for de-duping
      var paths = {}; // Each controller has a `routes` object
      // Connect all routes defined in controllers

      _lodash.default.forEach(router.controllers, function (controller) {
        _lodash.default.forEach(controller.routes, function (route) {
          // If no route path or action is defined, skip
          if (!_lodash.default.isString(route.path) || !_lodash.default.isFunction(route.action)) {
            // eslint-disable-next-line no-console
            console.warn('Skipping invalid route...');
            return;
          } // Route method defaults to `GET`


          var method = route.method ? route.method.toLowerCase() : 'get';
          var path = route.path.toLowerCase(); // If path/method has already been defined, skip

          if (paths[path] === method) {
            // eslint-disable-next-line no-console
            console.warn('Skipping duplicate route: [%s] %s', method, path);
            return;
          } // Setup controller scoped middleware
          // These apply to all routes in the controller


          var before = _lodash.default.invokeMap(controller.before, 'bind', controller) || [];
          var after = _lodash.default.invokeMap(controller.after, 'bind', controller) || [];

          var _before = _lodash.default.invokeMap(controller._before, 'bind', controller) || [];

          var _after = _lodash.default.invokeMap(controller._after, 'bind', controller) || []; // Build the route handler (callback)


          var handler = router._buildHandler(controller, route); // Connect the route
          // route.middleware is DEPRECATED


          var routeBefore = route.before || route.middleware || [];
          var routeAfter = route.after || [];
          router[method](path, _before, routeBefore, before, handler, after, routeAfter, _after); // Add route to set of connected routes

          router.routes.push({
            method: method,
            path: path
          }); // Use for de-duping

          paths[path] = method;
        });
      });
    },

    /**
     * Return a route handler/callback
     *
     * @param {Controller} controller
     * @param {Object} route
     * @return {Function}
     */
    _buildHandler: function _buildHandler(controller, route) {
      return function (req, res, next) {
        // Use sanitizer (TODO: DEPRECATED)
        var sanitizer = route.sanitizer;

        if (sanitizer) {
          _lodash.default.forEach(sanitizer, function (defs, field) {
            _lodash.default.forEach(defs, function (val, key) {
              if (_lodash.default.isPlainObject(val)) {
                req.sanitize(field)[key].call(req.sanitize(field), val);
              } else if (val === true) {
                req.sanitize(field)[key].call(req.sanitize(field));
              }
            });
          });
        } // Use validator (TODO: DEPRECATED)


        var validator = route.validator;

        if (validator) {
          req.check(validator);

          if (req.validationErrors().length) {
            return next(new Error('Validation Error.'));
          }
        } // Omit disallowed params


        req.blacklist = route.blacklist || [];

        if (req.blacklist.length) {
          req.params = _lodash.default.omit(req.params, req.blacklist);
          req.query = _lodash.default.omit(req.query, req.blacklist);
          req.body = _lodash.default.omit(req.body, req.blacklist);
        } // Pick allowed params


        req.whitelist = route.whitelist || [];

        if (req.whitelist.length) {
          req.params = _lodash.default.pick(req.params, req.whitelist);
          req.query = _lodash.default.pick(req.query, req.whitelist);
          req.body = _lodash.default.pick(req.body, req.whitelist);
        } // Execute the route for the request


        return route.action.call(controller, req, res, next);
      };
    }
  });

  return router;
}