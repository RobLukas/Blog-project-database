"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _stringify = _interopRequireDefault(require("@babel/runtime/core-js/json/stringify"));

var _assign = _interopRequireDefault(require("@babel/runtime/core-js/object/assign"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _lodash = _interopRequireDefault(require("lodash"));

var _xml2js = _interopRequireDefault(require("xml2js"));

function getOrderDirection(dir) {
  switch (dir) {
    case 'desc':
    case '-1':
      return 'DESC';

    case 'asc':
    case '1':
    default:
      return 'ASC';
  }
}

var Controller =
/*#__PURE__*/
function () {
  function Controller(_ref) {
    var app = _ref.app,
        db = _ref.db,
        wss = _ref.wss;
    (0, _classCallCheck2.default)(this, Controller);
    this.app = app;
    this.db = db;
    this.wss = wss; // Controller defined routes

    this.routes = []; // Controller defined middleware (runs immediately before and after route handler)

    this.before = [];
    this.after = []; // Internal before/after middleware

    this._before = [];
    this._after = [this.successResponse, this.errorResponse, this.finalResponse]; // Support optional XML response format

    this.xmlBuilder = new _xml2js.default.Builder({
      renderOpts: {
        pretty: false
      }
    });
  }

  (0, _createClass2.default)(Controller, [{
    key: "addRoutes",
    value: function addRoutes(routes) {
      this.routes = (0, _toConsumableArray2.default)(this.routes).concat((0, _toConsumableArray2.default)(routes));
    }
    /* Middleware */
    // TODO: Parse created_at/updated_at bounding

  }, {
    key: "parseFields",
    value: function parseFields(req) {
      var fields = req.query.fields || req.query.attributes;

      if (!_lodash.default.isString(fields)) {
        return [];
      }

      return fields.replace(/\s+/g, '').split(',');
    }
  }, {
    key: "parsePagination",
    value: function parsePagination(req) {
      var page = _lodash.default.parseInt(req.query.page) || 0;
      var offset = _lodash.default.parseInt(req.query.offset || req.query.skip || this.offset) || 0;
      var limit = _lodash.default.parseInt(req.query.limit || req.query.count || this.limit) || 0;

      if (limit === 0) {
        // no limit, page is always 1
        page = 1;
      } else if (page > 0) {
        // page was specified
        offset = (page - 1) * limit;
      } else if (limit > 0) {
        // limit and offset was specified
        page = _lodash.default.ceil((offset + 1) / limit);
      } else {
        // default page to 1
        page = 1;
      }

      return {
        page: page,
        offset: offset,
        limit: limit
      };
    }
  }, {
    key: "parseOrdering",
    value: function parseOrdering(req) {
      if (!req.query.order) {
        return [];
      }

      var order = [];
      var pairs = req.query.order.split(',');
      pairs.forEach(function (pair) {
        var _pair$split = pair.split('|'),
            _pair$split2 = (0, _slicedToArray2.default)(_pair$split, 2),
            key = _pair$split2[0],
            _pair$split2$ = _pair$split2[1],
            dir = _pair$split2$ === void 0 ? 'asc' : _pair$split2$;

        order.push([key, getOrderDirection(dir)]);
      });
      return order;
    }
  }, {
    key: "parseQueryParams",
    value: function parseQueryParams(req) {
      var _this = this;

      if (!this.queryParams) {
        return {};
      }

      var query = {};
      var queries = [];

      var params = _lodash.default.pick(req.query, _lodash.default.keys(this.queryParams));

      var logicalOperator = "$".concat((req.query.logical || 'and').toLowerCase().replace(/[@\s]/g, ''));

      _lodash.default.forEach(params, function (param, key) {
        // Make sure val is a string (should usually be from express)
        var val = !_lodash.default.isString(param) ? param.toString() : param; // If value is `*`, ignore this param

        if (val === '*') {
          return;
        } // Support `,` as `$or` for each param


        var vals = val.split(','); // No value, ignore this param

        if (vals.length === 0) {
          return;
        } // The built query filter


        var filter = {}; // Get param type defined in `queryParams`

        var type = _this.queryParams[key]; // Deal with different param types

        if (type === 'bool' || type === 'boolean') {
          vals = _lodash.default.map(vals, function (v) {
            if (v === 'true' || v === 'yes' || v === '1') {
              return true;
            } else if (v === 'false' || v === 'no' || v === '0') {
              return false;
            }

            return false;
          });
        } else if (type === 'string') {// strings and objectid
          // no transformation
        } else if (type === 'like') {
          // SQL LIKE (case insensitive)
          vals = _lodash.default.map(vals, function (v) {
            return {
              $like: v
            };
          });
        } else if (type === 'ilike') {
          // SQL LIKE (case insensitive)
          vals = _lodash.default.map(vals, function (v) {
            return {
              $iLike: v
            };
          });
        } else if (type === 'integer') {
          // integers
          vals = _lodash.default.map(vals, function (v) {
            return _lodash.default.parseInt(v);
          });
        } else if (type === 'float') {
          // floats
          vals = _lodash.default.map(vals, function (v) {
            return parseFloat(v);
          });
        } else {
          // invalid or unknown type
          return;
        } // If there is only one val, no need to use `$or`


        if (vals.length === 1) {
          // Treat `[]` as empty array
          filter[key] = vals[0] === '[]' ? [] : vals[0];
        } else {
          var orExpr = [];

          _lodash.default.forEach(vals, function (orVal) {
            var orClause = {};
            orClause[key] = orVal;
            orExpr.push(orClause);
          });

          filter.$or = orExpr;
        }

        queries.push(filter);
      }); // Combine the query


      if (queries.length === 1) {
        _lodash.default.assign(query, queries[0]);
      } else if (queries.length > 0) {
        query[logicalOperator] = queries;
      }

      return query;
    }
  }, {
    key: "getErrorType",
    value: function getErrorType(error) {
      if (error.type) {
        return error.type;
      }

      var errorType;

      switch (error.statusCode) {
        case 400:
          errorType = 'BAD_REQUEST';
          break;

        case 401:
          errorType = 'UNAUTHORIZED';
          break;

        case 402:
          errorType = 'PAYMENT_REQUIRED';
          break;

        case 403:
          errorType = 'FORBIDDEN';
          break;

        case 404:
          errorType = 'NOT_FOUND';
          break;

        case 405:
          errorType = 'METHOD_NOT_ALLOWED';
          break;

        case 406:
          errorType = 'NOT_ACCEPTABLE';
          break;

        case 409:
          errorType = 'CONFLICT';
          break;

        case 410:
          errorType = 'GONE';
          break;

        case 412:
          errorType = 'PRECONDITION_FAILED';
          break;

        case 422:
          errorType = 'UNPROCESSABLE_ENTITY';
          break;

        case 429:
          errorType = 'TOO_MANY_REQUESTS';
          break;

        case 500:
          errorType = 'INTERNAL_SERVER_ERROR';
          break;

        case 501:
          errorType = 'NOT_IMPLEMENTED';
          break;

        case 502:
          errorType = 'GATEWAY_ERROR';
          break;

        case 503:
          errorType = 'SERVICE_UNAVAILABLE';
          break;

        default:
          {
            if (error.statusCode >= 400 && error.statusCode < 500) {
              errorType = 'UNKNOWN_CLIENT_ERROR';
            } else if (error.statusCode >= 500) {
              errorType = 'UNKNOWN_SERVER_ERROR';
            } else {
              errorType = 'UNKNOWN_ERROR';
            }

            break;
          }
      }

      return errorType;
    }
  }, {
    key: "getErrorMessage",
    value: function getErrorMessage(error) {
      var msg;

      if (error.message) {
        return error.message;
      }

      if (error.statusCode >= 400 && error.statusCode < 500) {
        msg = 'Client Error';
      } else if (error.statusCode >= 500) {
        msg = 'Internal Server Error';
      } else {
        msg = 'Unknown Error';
      }

      return msg;
    }
  }, {
    key: "successResponse",
    value: function successResponse(req, res, next) {
      var envelope = {
        meta: {
          statusCode: res.statusCode
        },
        data: res.data || {}
      }; // Extend meta (optional)

      if (_lodash.default.isPlainObject(res.meta)) {
        (0, _assign.default)(envelope.meta, res.meta);
      } // Paging (optional)


      if (_lodash.default.isPlainObject(res.paging)) {
        envelope.meta.paging = res.paging;
      } // Response


      res.envelope = res.statusCode !== 204 ? envelope : undefined;
      next();
    }
    /**
     * Error
     * - statusCode or status (http status code - number)
     * - type (internal error type - string)
     * - message (human readable - string)
     * - line (stack trace - string)
     */

  }, {
    key: "errorResponse",
    value: function errorResponse(err, req, res, next) {
      var error = new Error();
      error.statusCode = _lodash.default.parseInt(err.statusCode) || _lodash.default.parseInt(err.status) || 500;
      error.type = this.getErrorType(err);
      error.message = this.getErrorMessage(err);
      error.meta = err.meta || {};
      error.data = err.data || {}; // Try and extract the line in which the error was caught

      if (err.stack) {
        try {
          error.line = err.stack.split('\n')[1].match(/at\s(.*)/)[1];
        } catch (e) {
          error.line = null;
        }
      }

      var envelope = {
        meta: {
          statusCode: error.statusCode,
          errorType: error.type,
          errorMessage: error.message
        },
        data: error.data
      }; // Error Line from Stack (optional)

      if (error.line) {
        envelope.meta.errorLine = error.line;
      } // Response


      res.status(error.statusCode);
      res.error = error;
      res.err = error;
      res.envelope = envelope;
      next();
    }
    /**
     * Attempts to respond to the request with data or error
     * Can respond in either `json` or `xml` format
     */

  }, {
    key: "finalResponse",
    value: function finalResponse(req, res) {
      // If we timed out before managing to respond, don't send the response
      if (res.headersSent) {
        return;
      } // Look for `.json` or `.xml` extension in path
      // And override request accept header


      if (/.json$/.test(req.path)) {
        req.headers.accept = 'application/json';
      } else if (/.xml$/.test(req.path)) {
        req.headers.accept = 'application/xml';
      } // Use request accept header to determine response content-type


      var xmlBuilder = this.xmlBuilder;
      res.format({
        json: function json() {
          res.jsonp(res.envelope);
        },
        xml: function xml() {
          try {
            var xmlData = JSON.parse((0, _stringify.default)(res.envelope));
            var xml = xmlBuilder.buildObject(xmlData);
            res.set('Content-Type', 'application/xml; charset=utf-8');
            res.send(xml);
          } catch (e) {
            res.status(500).end();
          }
        },
        text: function text() {
          res.send(res.envelope);
        },
        default: function _default() {
          res.status(406).send('Not Acceptable');
        }
      });
    }
  }]);
  return Controller;
}();

exports.default = Controller;